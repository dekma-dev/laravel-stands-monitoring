# App
Данная документация содержит в себе информацию о пользовательских моделях, контроллерах, трейтах и прочих классах. Её целью **не** является полное описание как проекта, так и фреймворка в целом.
## Models
Сейчас: практически все методы в ```HistoryController``` взаимодействуют напрямую с архивом *archive*, октуда вытягиваются данные в *historeis* что нелогично. Однако так реализовано.
Должно быть: работа с отображением на главной и обновлением, например, должна быть связана только с *histories* откуда **периодически** они отсылаются в *archive*. Отображение полной информации по конкретной метке, удаление, поиск всех меток глобально очевидно производится через *archive*. 
### Archive
Инфа о модели ```Arhcive```. Непосредственно связана с таблицей *archive*.
### History
Инфа о модели ```History```. Непосредственно связана с таблицей *histories*.
## Controllers
Согласно паттерну MVC -> Model - View - Controller, в контроллерах описана логика запросов и обработки данных, а так же открытия страниц и перенаправления.
### ArchiveController
Инфа о контроллере ```ArhciveController```. Непосредственно связан с моделью ```Archive```.
### HistoryController
Контроллер непосредственно связан со своей моделью ```History```, однако взаимодействия с ```Archive``` присутствуют активным образом. Это неправильно. Может быть. А может и нет. А может да и хер с ним.

Работа с представлением главной страницы ```route::/``` осуществляется в методе ```index()```. Главное взаимодействие происходит с ```Hisory```, где хранится до 100 записей для быстрого доступа.
Эти записи пуллятся из ```Archive``` **по определённому обстоятельству**. Алгоритм обновления следующий: происходит запрос к ```Archive``` с целью получения 100 последних уникальных(таблица *archive* содержит в себе историю работ всех меток, соответственно записей об одной и той же метке может быть множество) записей. Либо же сравнением хэша обновлять.

Создание метки посредством взаимодействия пользователя с GUI описана в методах ```create()``` и ```store(Request::)```, ```route:://create```. Согласно паттернам разработки Laravel, ```create()``` возвращает страницу для взаимодействия с пользователем, которая в свою очередь отправляет полученные с интерфейса данные в виде экземпляра класса ```Request``` в метод ```store()```, где происходит описана логика создания метки.
**Записи создаются в *archive* таблице, откуда пуллом летят в *histories* и отображаются на главной.**

Поиск метки реализован в методе пользовательском ```search(Request::, Archive::)```, маршрут ```route:://search?..```. Данные пуллятся из *archive* таблицы с расширенным поиском ```withTrashed()``` библиотеки ```SoftDeletes``` для поиска удаленных меток. Выводятся абсолютно все совпадения, все метки по запросу. Запрос может быть неполным, то есть нет необходимости в полнословном запросе.

Обновление данных через интерфейс (вручную) реализовано путём взаимодействия с GUI, который предоставляет метод ```edit(Request::, Archive::)```, располагающийся по роуту ```route::/edit```, сам метод лишь принимает данные и перенаправляет их в метод ```store(Request::, Archive::, History::)```, который не возвращает ничего, лишь проводит обновлением с помощью ```PATCH()``` запроса и перенаправляет в ```route::/``` на главную. Сами данные обновляются в ***archive* таблице, что неправильно**

```destoy(Request::, Archive::)```

```resotre(Request::, Archive::)```

Последний метод ```setOrUpdateData(Request::)``` работает только с данными, пришедшими с железа - МК, однако можно симитировать перейдя по роуту ```route::/sending?..```. Метод принимает данные с прямого запроса, записывает или обновляет данные в *archive*. Также производится расчёт количества смыканий путём сложения пришедших данных ```$request->count``` с количеством в базе ```$this->Count```.
## Events & Listeners
Классический событийно-ориентированный подход, реализация такая же, как в большинстве back-end фреймворках.
### Update Event & Listener
Данное событие и его слушатель вызываются при приёме данных с *автоматической* МК отправке по ```route::/sending?..```. Адрес задействует ```HistoryController->setOrUpdateData(Request::, Archive::)``` метод. Обновление данных происходит по формуле, где с текущего состояния вычитается пришедшее количество смыканий, делённое на износостойкость метки, результат приводится к %.  
